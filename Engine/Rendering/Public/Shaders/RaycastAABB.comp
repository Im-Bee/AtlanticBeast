#version 440

struct Voxel 
{
    uint    Type;
    uint    Color;
    uint    Id[26];
};

struct Cube 
{
    vec4    Pos;
    vec4    Rot;
    uint    Color;  
    vec4    HalfSize;  
};

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels 
{
    Voxel VoxelData[]; 
};
layout(std430, binding = 2) readonly buffer Cubes 
{
    Cube CubeData[]; 
};
layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    _Padding1;
    uint    _Padding2;
    uint    _Padding3;
};

const float INF     = 1.f / 0.f;
const float PI      = 3.141592;
const float TWO_PI  = PI * 2.;
const float EPSILON = 1e-4;
const vec4  baseSkyColor    = vec4(.4078, .4725, 1., 1.);
const vec3  lightPos        = vec3(20.0, 24.0, 10.0);
const vec3  lightColor      = vec3(1., 1., 1.);
const float maxRenderDist   = 20.f;
const int   maxSteps        = int(maxRenderDist * 2.6);

#define LAST_UNKNOWN_AXIS -1
#define LAST_X_AXIS 0
#define LAST_Y_AXIS 1
#define LAST_Z_AXIS 2

#define HIT_TYPE_UNKNOWN -1
#define HIT_TYPE_VOXEL 0
#define HIT_TYPE_OBJECT 1

// --------------------------------------------------------------------------------------------------------------------
mat3 RotationMatrix(in const vec3 angles) 
{
    float sx = sin(angles.x);
    float sy = sin(angles.y);
    float sz = sin(angles.z);
    float cx = cos(angles.x);
    float cy = cos(angles.y);
    float cz = cos(angles.z);

    mat3 rotX = mat3(1,  0,   0,  
                     0, cx, -sx,  
                     0, sx,  cx);

    mat3 rotY = mat3( cy, 0, sy,  
                       0, 1,  0,
                     -sy, 0, cy);

    mat3 rotZ = mat3(cz, -sz, 0,
                     sz,  cz, 0,
                     0,    0, 1);

    return rotX * rotY * rotZ;
}

// --------------------------------------------------------------------------------------------------------------------
bool IntersectRayAABB(in const vec3 ro,
                      in const vec3 rd,
                      in const vec3 halfSize,
                      out float tMin, 
                      out float tMax)
{
    vec3 invDir = 1.0 / rd;
    vec3 t0s = (-halfSize - ro) * invDir;
    vec3 t1s = ( halfSize - ro) * invDir;

    vec3 tsmaller = min(t0s, t1s);
    vec3 tbigger  = max(t0s, t1s);

    tMin = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
    tMax = min(min(tbigger.x, tbigger.y), tbigger.z);

    return tMax >= max(tMin, 0.0);
}

// --------------------------------------------------------------------------------------------------------------------
vec3 CubeNormal(in const vec3 lP, 
                in const vec3 halfSizes) 
{
    vec3 bias = abs(abs(lP) - halfSizes);

    if (bias.x < bias.y && bias.x < bias.z)
        return vec3(sign(lP.x), 0.0, 0.0);
    else if (bias.y < bias.x && bias.y < bias.z)
        return vec3(0.0, sign(lP.y), 0.0);
    else
        return vec3(0.0, 0.0, sign(lP.z));
}

// --------------------------------------------------------------------------------------------------------------------
bool RayIntersects(in const vec3 ro, 
                   in const vec3 rd,
                   in const Cube onCube, 
                   out float    fHitMin,
                   out float    fHitMax,
                   out vec3     normal)
{
    const mat3 cubeRot = RotationMatrix(onCube.Rot.xyz);
    const mat3 invCubeRot = transpose(cubeRot);
    const vec3 lro = invCubeRot * (ro - onCube.Pos.xyz);
    const vec3 lrd = invCubeRot * rd;

    if (!IntersectRayAABB(lro, 
                          lrd,
                          onCube.HalfSize.xyz,
                          fHitMin,
                          fHitMax)) 
    {
        return false;
    }

    normal = normalize(cubeRot * CubeNormal(lro + lrd * fHitMin, onCube.HalfSize.xyz));

    return true;
}

// --------------------------------------------------------------------------------------------------------------------
bool TestObjects(in const Voxel onVoxel,
                 in const vec3  ro,
                 in const vec3  rd,
                 out uint   uHitIndex,
                 out float  fDistance,
                 out vec3   hitCoords,
                 out vec3   normal)
{
    fDistance = INF;
    
    uint uLastId;
    float fLastHitMin;
    float fLastHitMax;
    vec3 lastNormal;
    for (uint k = 0; k < onVoxel.Type; ++k) 
    {
        uLastId = onVoxel.Id[k];
        if (!RayIntersects(ro, 
                           rd,
                           CubeData[uLastId],
                           fLastHitMin,
                           fLastHitMax,
                           lastNormal)) 
        {
            continue;
        }

        if (fLastHitMin < fDistance &&
            fLastHitMin >= EPSILON && 
            fLastHitMin < INF)
        {
            uHitIndex   = uLastId;
            fDistance   = fLastHitMin;
            normal      = lastNormal;
        }
    }

    // Check if the hit was valid
    if (fDistance != INF) {
        hitCoords = ro + rd * fDistance;
        return true;
    } 
    else {
        return false;
    }
}

// --------------------------------------------------------------------------------------------------------------------
bool MarchTheRay(in const vec3  ro,
                 in const vec3  rd,
                 in const int   maxSteps,
                 out vec3   hitCoords,
                 out uint   hitIndex,
                 out float  fDistance,
                 out vec3   normal,
                 out int    hitType)
{
    ivec3 voxel = ivec3(ro);
    ivec3 step  = ivec3(sign(rd));

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;
    
    // Calc initial offset
    for (int i = 0; i < 3; ++i) {
        float offset = rd[i] > 0.0 ?
                       1.0 - fract(ro[i]) : 
                       fract(ro[i]);

        tMax[i] = tDelta[i] * offset;
    }

    int lastStepAxis = LAST_UNKNOWN_AXIS;
    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x <= 0 || voxel.x >= GridSize.x ||
            voxel.y <= 0 || voxel.y >= GridSize.y ||
            voxel.z <= 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;
    
        // Check for hits
        if (VoxelData[index].Type == uint(-1))
        {
            if (lastStepAxis == LAST_X_AXIS) {
                fDistance = tMax.x - tDelta.x;
            }
            else if (lastStepAxis == LAST_Y_AXIS) {
                fDistance = tMax.y - tDelta.y;
            }
            else {
                fDistance = tMax.z - tDelta.z;
            }

            normal               = vec3(0.);
            normal[lastStepAxis] = -float(step[lastStepAxis]);

            hitIndex    = index;
            hitCoords   = ro + rd * fDistance;
            hitType     = HIT_TYPE_VOXEL;

            return true;
        } 
        if (VoxelData[index].Type > 0 &&
            TestObjects(VoxelData[index],
                        ro,
                        rd,
                        hitIndex,
                        fDistance,
                        hitCoords,
                        normal))
        {
            hitType = HIT_TYPE_OBJECT;
            return true;
        }
    
        // Move the ray
        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x  += tDelta.x;
                lastStepAxis = LAST_X_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y  += tDelta.y;
                lastStepAxis = LAST_Y_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        }

    }

    return false;
}

// --------------------------------------------------------------------------------------------------------------------
vec4 ExtractColorInt(in const uint uPackedColor)
{        
    float r = float((uPackedColor >> 24) & 0xFFu) / 255.;
    float g = float((uPackedColor >> 16) & 0xFFu) / 255.;
    float b = float((uPackedColor >>  8) & 0xFFu) / 255.;
    float a = float(uPackedColor         & 0xFFu) / 255.;
    
    return vec4(r, g, b, a);
}

// --------------------------------------------------------------------------------------------------------------------
bool ShadowRay(in const vec3 from, 
               in const vec3 to, 
               in const int maxDistance)
{
    const vec3 dir = normalize(to - from);
    vec3    dummyHit;
    uint    dummyIndex;
    vec3    dummyNormal;
    float   dummyDistance;
    int     dummyHitType;

    return MarchTheRay(from + dir * EPSILON,
                       dir,
                       maxDistance,
                       dummyHit,
                       dummyIndex,
                       dummyDistance,
                       dummyNormal,
                       dummyHitType);
}

// --------------------------------------------------------------------------------------------------------------------
float Random(in const vec2 uv)
{
    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
}

// --------------------------------------------------------------------------------------------------------------------
vec3 RandomPointOnHemisphere(in const vec3 normal)
{
    vec3 randPoint = vec3(Random(gl_GlobalInvocationID.xy - normal.yx) - .5,
                          Random(gl_GlobalInvocationID.xy) - .5, 
                          Random(gl_GlobalInvocationID.yx + normal.xy) - .5);

    randPoint = normalize(randPoint);

    if (dot(randPoint, normal) < 0.0)
        randPoint = -randPoint;

    return randPoint;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 RandomColor()
{
    return normalize(vec3(Random(gl_GlobalInvocationID.xy) - 123.5,
                          Random(gl_GlobalInvocationID.xy) - .52234, 
                          Random(gl_GlobalInvocationID.yx) - 239809.5));
}


// --------------------------------------------------------------------------------------------------------------------
float SoftShadowRay(in const vec3 from, 
                    in const vec3 to, 
                    in const vec3 normal, 
                    in const int maxDistance)
{
    const float r = 4.;
    const float samples = 16;

    vec3    dir = normalize(to - from);
    vec3    dummyHit;
    uint    dummyIndex;
    vec3    dummyNormal;
    float   dummyDistance;
    int     dummyHitType;
    float   shadow = 1.;
    
    const float sampleStep  = TWO_PI / samples;
    const float mixFactor   = 0.015;

    float angle;
    vec3 offset;
    for (int i = 0; i < samples; ++i)
    {
        angle   = float(i) * sampleStep;
        offset  = vec3(cos(angle), sin(angle), 0.0) * r; 

        dir = normalize(to + offset - from);
        dir = mix(dir, RandomPointOnHemisphere(normal), mixFactor);

        if (MarchTheRay(from + dir * EPSILON,
                        dir,
                        maxDistance,
                        dummyHit,
                        dummyIndex,
                        dummyDistance,
                        dummyNormal,
                        dummyHitType)) 
        {
            shadow -= (1. / samples);
        }
    }

    return shadow;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 Phong(in const vec3   camPos,
           in const vec3   pos,
           in const vec3   normal,
           in const int    maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - pos);
    vec3 viewDir    = normalize(camPos   - pos);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor;
    vec3 specular   = specularStrength * spec * lightColor;

    return ambient + diffuse + specular;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 PhongShadows(in const vec3   camPos,
                  in const vec3   pos,
                  in const vec3   normal,
                  in const int    maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - pos);
    vec3 viewDir    = normalize(camPos   - pos);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    float shadow = ShadowRay(pos, lightPos, int(maxDistance )) ? 0.05 : 1.0;

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 PhongSoftShadows(in vec3   camPos,
                      in vec3   pos,
                      in vec3   normal,
                      in int    maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - pos);
    vec3 viewDir    = normalize(camPos   - pos);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    float shadow = SoftShadowRay(pos, lightPos, normal, int(maxDistance));

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 Reflection(in vec3     from,
                in vec3     to,
                in const int    maxSteps,
                in const uint   bounces,
                in const vec3   baseColor,
                in vec3     normal,
                in float    MaterialReflectPower)
{
    float   localReflect;
    vec3    incident;
    vec3    dir;
    vec3    hit;
    uint    index;
    float   fDistance = 1.;
    vec3    normalRef;
    int     hitType;

    vec3 reflectedColor = baseColor;
    vec4 hitBaseColor;
    const float roughness = 0.08;

    for (uint i = 0; i < bounces; ++i)
    {
        if (MaterialReflectPower <= 0.0)
            break;

        dir = reflect(normalize(to - from), normal);
        dir = mix(dir, RandomPointOnHemisphere(normal), roughness * fDistance * 0.25);

        if (!MarchTheRay(to + dir * EPSILON,
                         dir,
                         maxSteps,
                         hit,
                         index,
                         fDistance,
                         normalRef,
                         hitType)) 
        {
            reflectedColor = mix(reflectedColor, baseSkyColor.xyz, MaterialReflectPower);
            break;
        }

        from    = to;
        to      = hit;
        normal  = normalRef;

        if (hitType == HIT_TYPE_VOXEL) {
            hitBaseColor = ExtractColorInt(VoxelData[index].Color);
            localReflect = 0.23;
        }
        else if (hitType == HIT_TYPE_OBJECT) {
            hitBaseColor = ExtractColorInt(CubeData[index].Color);
            localReflect = 0.23;
        } 
        else {
            hitBaseColor = baseSkyColor;
            localReflect = 0;
        }
        
        reflectedColor = mix(reflectedColor, 
                             PhongShadows(CameraPos.xyz, hit, normal, int(maxSteps * 0.25)) * hitBaseColor.xyz,
                             MaterialReflectPower);

        MaterialReflectPower *= localReflect * 2;
    }

    return reflectedColor;
}

// --------------------------------------------------------------------------------------------------------------------
bool IsCrossHair(in const vec2 uv, 
                 in const float aspectRatio) 
{
    const float fCrossHairWidth = 0.0026;
    float fCrossHairWidthX = fCrossHairWidth;
    float fCrossHairWidthY = fCrossHairWidth;

    if (aspectRatio >= 1.f) {
        fCrossHairWidthY *= aspectRatio;
    } else {
        fCrossHairWidthX *= aspectRatio;
    }

    return abs(uv).x < fCrossHairWidthX && abs(uv).y < fCrossHairWidthY;
}

// --------------------------------------------------------------------------------------------------------------------
void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov       = Fov * 0.5;
    float aspectRatio   = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale         = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 ro  = CameraPos.xyz;
    vec3 rd  = normalize(CameraLookDir.xyz +
                         uv.x * aspectRatio * scale * CameraRight.xyz +
                         uv.y * scale * CameraUp.xyz);

    if (IsCrossHair(uv, aspectRatio)) 
    {
        imageStore(outputImage, pixelCoord, vec4(1., 1., 1., 1.));
        return;
    }
    vec4 finalColor = baseSkyColor;

    vec3 hitPos;
    uint index;
    float fDistance;
    vec3 normal;
    int hitType;

    if (MarchTheRay(ro, rd, maxSteps, hitPos, index, fDistance, normal, hitType)) 
    {
        if (hitType == HIT_TYPE_VOXEL) {
            finalColor = ExtractColorInt(VoxelData[index].Color);
        }
        if (hitType == HIT_TYPE_OBJECT) {
            finalColor = ExtractColorInt(CubeData[index].Color);
        }

        if (fDistance <= maxSteps) 
        {   
            vec3 shaded = finalColor.xyz;

            shaded = PhongSoftShadows(CameraPos.xyz, 
                                      hitPos,
                                      normal,
                                      int(distance(hitPos, lightPos) * 1.5)) * shaded;

            // finalColor = vec4(shaded, finalColor.w);
            finalColor = vec4(Reflection(ro, 
                                         hitPos, 
                                         int(maxSteps * 0.5f), 
                                         4, 
                                         shaded,
                                         normal,
                                         0.25),
                              finalColor.w);
        }
    }

    if (fDistance > maxRenderDist) {
        finalColor = mix(finalColor, 
                         baseSkyColor,
                         clamp(fDistance - maxRenderDist, 
                               0.f,
                               maxRenderDist * .5f) / (maxRenderDist * .5f));
    }

    imageStore(outputImage, pixelCoord, finalColor);
}


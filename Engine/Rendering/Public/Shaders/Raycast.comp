#version 450
#extension GL_ARB_shading_language_include : enable
#include "Common.glsl"
#include "Math.glsl"
#include "Random.glsl"
#include "Colors.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint    Type;
    uint    Color;
    float   MaterialReflectPower;
    uint    Padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel VoxelData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    Padding1;
    uint    Padding2;
    uint    Padding3;
};

const vec4  baseSkyColor    = vec4(.4078, .4725, 1., 1.);
const float maxRenderDist   = 50.f;
const int   maxSteps        = int(maxRenderDist * 2.6);
const vec3  lightPos        = vec3(20.0, 24.0, 10.0);
const vec3  lightColor      = vec3(1., 1., 1.);

#define LAST_UNKNOWN_AXIS -1
#define LAST_X_AXIS 0
#define LAST_Y_AXIS 1
#define LAST_Z_AXIS 2

bool MarchTheRay(vec3 ro,
                 vec3 rd,
                 int maxSteps,
                 out ivec3 hitCoords,
                 out int hitIndex,
                 out float distance,
                 out vec3 normal)
{
    ivec3 voxel = ivec3(ro);
    ivec3 step  = ivec3(sign(rd));

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;

    for (int i = 0; i < 3; ++i) {
        float offset = rd[i] > 0.0 ?
                       1.0 - fract(ro[i]) : 
                       fract(ro[i]);

        tMax[i] = tDelta[i] * offset;
    }

    int lastStepAxis = LAST_UNKNOWN_AXIS;
    distance = 0.;
    normal = vec3(0.);

    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x < 0 || voxel.x >= GridSize.x ||
            voxel.y < 0 || voxel.y >= GridSize.y ||
            voxel.z < 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;

        if (VoxelData[index].Type == 1)
        {
            hitCoords   = voxel;
            hitIndex    = index;
            normal[lastStepAxis] = -float(step[lastStepAxis]);

            if (lastStepAxis == LAST_X_AXIS) {
                distance = tMax.x - tDelta.x;
            }
            else if (lastStepAxis == LAST_Y_AXIS) {
                distance = tMax.y - tDelta.y;
            }
            else {
                distance = tMax.z - tDelta.z;
            }

            return true;
        }

        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x  += tDelta.x;
                lastStepAxis = LAST_X_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y  += tDelta.y;
                lastStepAxis = LAST_Y_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        }
    }

    return false;
}

bool ShadowRay(vec3 from, vec3 to, int maxDistance)
{
    vec3    dir = normalize(to - from);
    ivec3   dummyHit;
    int     dummyIndex;
    float   dummyDistance;
    vec3    dummyNormal;

    return MarchTheRay(from + dir * EPSILON,
                       dir,
                       maxDistance,
                       dummyHit,
                       dummyIndex,
                       dummyDistance,
                       dummyNormal);
}

float SoftShadowRay(vec3 from, vec3 to, in vec3 normal, int maxDistance)
{
    const float r = 4.;
    const float samples = 18;

    vec3    dir = normalize(to - from);
    ivec3   dummyHit;
    int     dummyIndex;
    float   dummyDistance;
    vec3    dummyNormal;
    float   shadow = 1.;
    
    const float sampleStep = TWO_PI / samples;
    const float mixFactor = 0.025;

    for (int i = 0; i < samples; ++i)
    {
        float angle = float(i) * sampleStep;
        vec3 offset = vec3(cos(angle), sin(angle), 0.0) * r; 
        vec3 point  = to + offset;

        dir = normalize(point - from);
        dir = mix(dir, RandomPointOnHemisphere(normal), mixFactor);

        if (MarchTheRay(from + dir * EPSILON,
                        dir,
                        maxDistance,
                        dummyHit,
                        dummyIndex,
                        dummyDistance,
                        dummyNormal)) 
        {
            shadow -= (1. / samples);
        }
    }

    return shadow;
}

vec3 PhongShadows(in vec3 camPos,
                  in vec3 pos,
                  in vec3 coord,
                  in vec3 normal,
                  in int maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - coord);
    vec3 viewDir    = normalize(camPos   - coord);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    // float shadow = ShadowRay(pos, lightPos, int(maxDistance * 0.5)) ? 0.05 : 1.0;
    float shadow = SoftShadowRay(pos, lightPos, normal, int(maxDistance));

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

vec3 Reflection(vec3 from,
                vec3 to,
                int maxSteps,
                uint bounces,
                vec3 normal,
                vec3 baseColor,
                float MaterialReflectPower)
{
    float localReflect = MaterialReflectPower;

    vec3 incident;
    vec3 dir;
    ivec3 hit;
    int index;
    float distance;
    vec3 normalRef;

    vec3 reflectedColor = baseColor;
    vec3 hitBaseColor;
    const float roughness = 0.02;

    for (uint i = 0; i < bounces; ++i)
    {
        if (localReflect <= 0.0)
            break;

        dir = reflect(normalize(to - from), normal);
        dir = mix(dir, RandomPointOnHemisphere(normal), roughness);

        if (!MarchTheRay(to + dir * EPSILON,
                        dir,
                        maxSteps,
                        hit,
                        index,
                        distance,
                        normalRef)) 
        {
            reflectedColor = mix(reflectedColor, baseSkyColor.xyz, localReflect);
            break;
        }

        from    = to;
        to      = to + dir * distance;
        normal  = normalRef;

        hitBaseColor = ExtractColorInt(VoxelData[index].Color).xyz;
        
        reflectedColor = mix(reflectedColor, 
                             PhongShadows(CameraPos.xyz, to, hit, normal, maxSteps) * hitBaseColor,
                             localReflect);

        localReflect *= VoxelData[index].MaterialReflectPower * 2;
    }

    return reflectedColor;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov = Fov * 0.5;
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 
    if (IsCrosshair(uv, aspectRatio)) 
    {
        imageStore(outputImage, pixelCoord, vec4(1., 1., 1., 1.));
        return;
    }

    vec3 rayDir = normalize(CameraLookDir.xyz +
                            uv.x * aspectRatio * scale * CameraRight.xyz +
                            uv.y * scale * CameraUp.xyz);
     
    vec3 rayOrigin  = CameraPos.xyz;

    vec4 finalColor = baseSkyColor;

    ivec3   hitCoords;
    int     index = 0;
    vec3    normal;
    float   distance;

    if (MarchTheRay(rayOrigin, rayDir, maxSteps, hitCoords, index, distance, normal)) 
    {
        vec3 hitPos = rayOrigin + rayDir * distance;
        finalColor = ExtractColorInt(VoxelData[index].Color);


        if (distance <= maxSteps) {
            vec3 shading = PhongShadows(CameraPos.xyz, 
                                        hitPos,
                                        hitCoords,
                                        normal,
                                        int(length(hitPos - lightPos) * 1.5));

            finalColor = vec4(Reflection(rayOrigin, 
                                         hitPos, 
                                         96, 
                                         4, 
                                         normal,
                                         shading * ExtractColorInt(VoxelData[index].Color).xyz, 
                                         VoxelData[index].MaterialReflectPower),
                              finalColor.w);
        }
    }

    if (distance > maxRenderDist) {
        finalColor = mix(finalColor, 
                         baseSkyColor,
                         clamp(distance - maxRenderDist, 0.f, maxRenderDist * .5f) / (maxRenderDist * .5f));
    }

    imageStore(outputImage, pixelCoord, finalColor);
}


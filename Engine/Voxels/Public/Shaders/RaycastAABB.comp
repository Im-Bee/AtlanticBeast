#version 440

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel 
{
    uint    Type;
    uint    id[3];
};

struct Cube 
{
    vec4    Pos;
    vec4    Rot;
    vec4    HalfSize;
    vec4    Color;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels 
{
    Voxel VoxelData[]; 
};
layout(std430, binding = 2) readonly buffer Cubes 
{
    Cube CubeData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    Padding1;
    uint    Padding2;
    uint    Padding3;
};

const float PI      = 3.141592;
const float TWO_PI  = 6.283185;
const float EPSILON = 0.0001;
const vec4  baseSkyColor    = vec4(.4078, .4725, 1., 1.);
const float maxRenderDist   = 50.f;
const int   maxSteps        = int(maxRenderDist * 2.6);

const vec3  lightPos    = vec3(20.0, 24.0, 10.0);
const vec3  lightColor  = vec3(1., 1., 1.);

#define LAST_UNKNOWN_AXIS -1
#define LAST_X_AXIS 0
#define LAST_Y_AXIS 1
#define LAST_Z_AXIS 2

bool TestHit(in uint uIndex, inout vec3 rayOriginLocal, in vec3 rayDirLocal, out vec3 normal) 
{
    return true;
}


bool MarchTheRay(vec3 ro,
                 vec3 rd,
                 int maxSteps,
                 out vec3 hitCoords,
                 out int hitIndex,
                 out vec3 normal)
{
    ivec3 voxel = ivec3(ro);
    ivec3 step  = ivec3(sign(rd));

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;

    for (int i = 0; i < 3; ++i) {
        float offset = rd[i] > 0.0 ?
                       1.0 - fract(ro[i]) : 
                       fract(ro[i]);

        tMax[i] = tDelta[i] * offset;
    }

    normal = vec3(0.);

    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x < 0 || voxel.x >= GridSize.x ||
            voxel.y < 0 || voxel.y >= GridSize.y ||
            voxel.z < 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;

        if (VoxelData[index].Type > 0)
        {
            return false;
            hitCoords = voxel;
            if (TestHit(VoxelData[index].id[0], hitCoords, rd, normal)) 
            {
                hitIndex = index;
                return true;
            }
        }

        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x  += tDelta.x;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y  += tDelta.y;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
            }
        }
    }

    return false;
}

vec4 ExtractColorInt(uint packedColor)
{        
    float r = float((packedColor >> 24) & 0xFFu) / 255.;
    float g = float((packedColor >> 16) & 0xFFu) / 255.;
    float b = float((packedColor >>  8) & 0xFFu) / 255.;
    float a = float(packedColor         & 0xFFu) / 255.;
    
    return vec4(r, g, b, a);
}

bool ShadowRay(vec3 from, vec3 to, int maxDistance)
{
    vec3    dir = normalize(to - from);
    vec3    dummyHit;
    int     dummyIndex;
    vec3    dummyNormal;

    return MarchTheRay(from + dir * EPSILON,
                       dir,
                       maxDistance,
                       dummyHit,
                       dummyIndex,
                       dummyNormal);
}

float Random(in vec2 uv)
{
    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 RandomPointOnHemisphere(vec3 normal)
{
    vec3 randPoint = vec3(Random(gl_GlobalInvocationID.xy - normal.yx) - .5,
                          Random(gl_GlobalInvocationID.xy) - .5, 
                          Random(gl_GlobalInvocationID.yx + normal.xy) - .5);

    randPoint = normalize(randPoint);

    if (dot(randPoint, normal) < 0.0)
        randPoint = -randPoint;

    return randPoint;
}

float SoftShadowRay(vec3 from, vec3 to, in vec3 normal, int maxDistance)
{
    const float r = 4.;
    const float samples = 18;

    vec3    dir = normalize(to - from);
    vec3    dummyHit;
    int     dummyIndex;
    vec3    dummyNormal;
    float   shadow = 1.;
    
    const float sampleStep = TWO_PI / samples;
    const float mixFactor = 0.015;

    for (int i = 0; i < samples; ++i)
    {
        float angle = float(i) * sampleStep;
        vec3 offset = vec3(cos(angle), sin(angle), 0.0) * r; 
        vec3 point  = to + offset;

        dir = normalize(point - from);
        dir = mix(dir, RandomPointOnHemisphere(normal), mixFactor);

        if (MarchTheRay(from + dir * EPSILON,
                        dir,
                        maxDistance,
                        dummyHit,
                        dummyIndex,
                        dummyNormal)) 
        {
            shadow -= (1. / samples);
        }
    }

    return shadow;
}

vec3 PhongShadows(in vec3 camPos,
                  in vec3 pos,
                  in vec3 normal,
                  in int maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - pos);
    vec3 viewDir    = normalize(camPos   - pos);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    // float shadow = ShadowRay(pos, lightPos, int(maxDistance * 0.5)) ? 0.05 : 1.0;
    float shadow = SoftShadowRay(pos, lightPos, normal, int(maxDistance));

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

vec3 Reflection(vec3 from,
                vec3 to,
                int maxSteps,
                uint bounces,
                vec3 normal,
                vec3 baseColor,
                float MaterialReflectPower)
{
    float localReflect = MaterialReflectPower;

    vec3 incident;
    vec3 dir;
    vec3 hit;
    int index;
    vec3 normalRef;

    vec3 reflectedColor = baseColor;
    vec3 hitBaseColor;
    const float roughness = 0.02;

    for (uint i = 0; i < bounces; ++i)
    {
        if (localReflect <= 0.0)
            break;

        dir = reflect(normalize(to - from), normal);
        dir = mix(dir, RandomPointOnHemisphere(normal), roughness);

        if (!MarchTheRay(to + dir * EPSILON,
                        dir,
                        maxSteps,
                        hit,
                        index,
                        normalRef)) 
        {
            reflectedColor = mix(reflectedColor, baseSkyColor.xyz, localReflect);
            break;
        }

        from    = to;
        to      = hit;
        normal  = normalRef;

        hitBaseColor = ExtractColorInt(0xFF00FFFF).xyz;
        
        reflectedColor = mix(reflectedColor, 
                             PhongShadows(CameraPos.xyz, hit, normal, maxSteps) * hitBaseColor,
                             localReflect);

        localReflect *= 0.23 * 2;
    }

    return reflectedColor;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov = Fov * 0.5;
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 rayDir = normalize(CameraLookDir.xyz +
                            uv.x * aspectRatio * scale * CameraRight.xyz +
                            uv.y * scale * CameraUp.xyz);
     
    vec3 rayOrigin  = CameraPos.xyz;


    vec4 finalColor = baseSkyColor;

    vec3    hitPos;
    int     index = 0;
    vec3    normal;

    if (MarchTheRay(rayOrigin, rayDir, maxSteps, hitPos, index, normal)) 
    {
        finalColor = ExtractColorInt(0x3300FFFF);


        // if (distance <= maxSteps) {
            vec3 shading = PhongShadows(CameraPos.xyz, 
                                        hitPos,
                                        normal,
                                        int(length(hitPos - lightPos) * 1.5));

            finalColor = vec4(Reflection(rayOrigin, 
                                         hitPos, 
                                         96, 
                                         6, 
                                         normal,
                                         shading * ExtractColorInt(0x3300FFFF).xyz, 
                                         0.25),
                              finalColor.w);
        // }
    }

    // if (distance > maxRenderDist)
    //     finalColor = mix(finalColor, 
    //                      baseSkyColor,
    //                      clamp(distance - maxRenderDist, 0.f, maxRenderDist * .5f) / (maxRenderDist * .5f));

    vec2 d = abs(uv);

    bool isVertical   = d.x < (2. / imageSize(outputImage).x);
    bool isHorizontal = d.y < (2. / imageSize(outputImage).y);

    if (isVertical && isHorizontal) {
        finalColor = mix(finalColor, vec4(1., 1., 1., 1.), 0.32);
    }

    imageStore(outputImage, pixelCoord, finalColor);
}


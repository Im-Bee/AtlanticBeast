#version 440

struct Voxel 
{
    uint    Type;
    uint    Color;
    uint    id[26];
};

struct Cube 
{
    vec4    Pos;
    vec4    Rot;
    uint    Color;  
    float   HalfSizeX;  
    float   HalfSizeY;  
    float   HalfSizeZ;  
};

layout(local_size_x = 16, local_size_y = 16) in;
layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels 
{
    Voxel VoxelData[]; 
};
layout(std430, binding = 2) readonly buffer Cubes 
{
    Cube CubeData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    Padding1;
    uint    Padding2;
    uint    Padding3;
};

const float PI      = 3.141592;
const float TWO_PI  = 6.283185;
const float EPSILON = 0.0001;
const vec4  baseSkyColor    = vec4(.4078, .4725, 1., 1.);
const float maxRenderDist   = 10.f;
const int   maxSteps        = int(maxRenderDist * 2.6);
const vec3  lightPos    = vec3(20.0, 24.0, 10.0);
const vec3  lightColor  = vec3(1., 1., 1.);

#define LAST_UNKNOWN_AXIS -1
#define LAST_X_AXIS 0
#define LAST_Y_AXIS 1
#define LAST_Z_AXIS 2

#define HIT_TYPE_UNKNOWN -1
#define HIT_TYPE_VOXEL 0
#define HIT_TYPE_OBJECT 1

// --------------------------------------------------------------------------------------------------------------------
mat3 RotationMatrix(vec3 angles) 
{
    float sx = sin(angles.x);
    float sy = sin(angles.y);
    float sz = sin(angles.z);
    float cx = cos(angles.x);
    float cy = cos(angles.y);
    float cz = cos(angles.z);

    mat3 rotX = mat3(1,  0,   0,  
                     0, cx, -sx,  
                     0, sx,  cx);

    mat3 rotY = mat3( cy, 0, sy,  
                       0, 1,  0,
                     -sy, 0, cy);

    mat3 rotZ = mat3(cz, -sz, 0,
                     sz,  cz, 0,
                     0,    0, 1);

    return rotX * rotY * rotZ;
}

// --------------------------------------------------------------------------------------------------------------------
bool IntersectRayAABB(vec3 ro, vec3 rd, vec3 halfSize, out float tMin, out float tMax)
{
    vec3 invDir = 1.0 / rd;
    vec3 t0s = (-halfSize - ro) * invDir;
    vec3 t1s = ( halfSize - ro) * invDir;

    vec3 tsmaller = min(t0s, t1s);
    vec3 tbigger  = max(t0s, t1s);

    tMin = max(max(tsmaller.x, tsmaller.y), tsmaller.z);
    tMax = min(min(tbigger.x, tbigger.y), tbigger.z);

    return tMax >= max(tMin, 0.0);
}

// --------------------------------------------------------------------------------------------------------------------
vec3 CubeNormal(vec3 lP, vec3 halfSize) 
{
    vec3 bias = abs(abs(lP) - halfSize);

    if (bias.x < EPSILON) 
        return vec3(sign(lP.x), 0, 0);
    else if (bias.y < EPSILON) 
        return vec3(0, sign(lP.y), 0);
    else if (bias.z < EPSILON) 
        return vec3(0, 0, sign(lP.z));
}

// --------------------------------------------------------------------------------------------------------------------
bool RayIntersects(vec3 rayOrigin, 
                   vec3 rayDir,
                   Cube cube, 
                   out float tHit,
                   out vec3 normal)
{
    mat3 cubeRotation   = RotationMatrix(cube.Rot.xyz);
    mat3 invRotation    = transpose(cubeRotation);

    vec3 localRayOrigin = invRotation * (rayOrigin - cube.Pos.xyz);
    vec3 localRayDir    = invRotation * rayDir;
    vec3 halfSize       = vec3(cube.HalfSizeX, cube.HalfSizeY, cube.HalfSizeZ);

    float tMin, tMaxDummy;

    if (!IntersectRayAABB(localRayOrigin, localRayDir, halfSize, tMin, tMaxDummy)) 
        return false;

    tHit = tMin;

    vec3 localHitPoint = localRayOrigin + localRayDir * tHit;
    vec3 localNormal = CubeNormal(localHitPoint, halfSize);
    normal = normalize(cubeRotation * localNormal);

    return true;
}

// --------------------------------------------------------------------------------------------------------------------
bool MarchTheRay(vec3 ro,
                 vec3 rd,
                 int maxSteps,
                 out vec3 hitCoords,
                 out uint hitIndex,
                 out float distance,
                 out vec3 normal,
                 out int hitType)
{
    ivec3 voxel = ivec3(ro);
    ivec3 step  = ivec3(sign(rd));

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;

    for (int i = 0; i < 3; ++i) {
        float offset = rd[i] > 0.0 ?
                       1.0 - fract(ro[i]) : 
                       fract(ro[i]);

        tMax[i] = tDelta[i] * offset;
    }

    float   hit;
    int     lastStepAxis = LAST_UNKNOWN_AXIS;
    distance = 1.f / 0.f;
    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x < 0 || voxel.x >= GridSize.x ||
            voxel.y < 0 || voxel.y >= GridSize.y ||
            voxel.z < 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;

        if (VoxelData[index].Type > 0)
        {
            if (VoxelData[index].Type == uint(-1))
            {
                hitCoords   = voxel;
                hitIndex    = index;
                normal      = vec3(0.);
                normal[lastStepAxis] = -float(step[lastStepAxis]);

                if (lastStepAxis == LAST_X_AXIS) {
                    distance = tMax.x - tDelta.x;
                }
                else if (lastStepAxis == LAST_Y_AXIS) {
                    distance = tMax.y - tDelta.y;
                }
                else {
                    distance = tMax.z - tDelta.z;
                }
                hitCoords = ro + rd * distance;
                hitType = HIT_TYPE_VOXEL;
                return true;
            }

            for (uint k = 0; k < VoxelData[index].Type; ++k) 
            {
                uint id = VoxelData[index].id[k];
                if (RayIntersects(ro, 
                                  rd,
                                  CubeData[id],
                                  hit,
                                  normal)) 
                {
                    if (distance > hit) {
                        distance    = hit;
                        hitIndex    = id;
                        hitCoords   = ro + rd * hit;
                        hitType     = HIT_TYPE_OBJECT;
                    }
                }
            }
            if (distance < (1.f / 0.f)) {
                return true;
            }
        }

        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x  += tDelta.x;
                lastStepAxis = LAST_X_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y  += tDelta.y;
                lastStepAxis = LAST_Y_AXIS;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = LAST_Z_AXIS;
            }
        }
    }

    return false;
}

// --------------------------------------------------------------------------------------------------------------------
vec4 ExtractColorInt(uint packedColor)
{        
    float r = float((packedColor >> 24) & 0xFFu) / 255.;
    float g = float((packedColor >> 16) & 0xFFu) / 255.;
    float b = float((packedColor >>  8) & 0xFFu) / 255.;
    float a = float(packedColor         & 0xFFu) / 255.;
    
    return vec4(r, g, b, a);
}

// --------------------------------------------------------------------------------------------------------------------
bool ShadowRay(vec3 from, vec3 to, int maxDistance)
{
    vec3    dir = normalize(to - from);
    vec3    dummyHit;
    uint    dummyIndex;
    vec3    dummyNormal;
    float   dummyDistance;
    int     dummyHitType;

    return MarchTheRay(from + dir * EPSILON,
                       dir,
                       maxDistance,
                       dummyHit,
                       dummyIndex,
                       dummyDistance,
                       dummyNormal,
                       dummyHitType);
}

// --------------------------------------------------------------------------------------------------------------------
float Random(in vec2 uv)
{
    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
}

// --------------------------------------------------------------------------------------------------------------------
vec3 RandomPointOnHemisphere(vec3 normal)
{
    vec3 randPoint = vec3(Random(gl_GlobalInvocationID.xy - normal.yx) - .5,
                          Random(gl_GlobalInvocationID.xy) - .5, 
                          Random(gl_GlobalInvocationID.yx + normal.xy) - .5);

    randPoint = normalize(randPoint);

    if (dot(randPoint, normal) < 0.0)
        randPoint = -randPoint;

    return randPoint;
}

// --------------------------------------------------------------------------------------------------------------------
float SoftShadowRay(vec3 from, vec3 to, in vec3 normal, int maxDistance)
{
    const float r = 4.;
    const float samples = 16;

    vec3    dir = normalize(to - from);
    vec3    dummyHit;
    uint    dummyIndex;
    vec3    dummyNormal;
    float   dummyDistance;
    int     dummyHitType;
    float   shadow = 1.;
    
    const float sampleStep = TWO_PI / samples;
    const float mixFactor = 0.015;

    for (int i = 0; i < samples; ++i)
    {
        float angle = float(i) * sampleStep;
        vec3 offset = vec3(cos(angle), sin(angle), 0.0) * r; 
        vec3 point  = to + offset;

        dir = normalize(point - from);
        dir = mix(dir, RandomPointOnHemisphere(normal), mixFactor);

        if (MarchTheRay(from + dir * EPSILON,
                        dir,
                        maxDistance,
                        dummyHit,
                        dummyIndex,
                        dummyDistance,
                        dummyNormal,
                        dummyHitType)) 
        {
            shadow -= (1. / samples);
        }
    }

    return shadow;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 PhongShadows(in vec3 camPos,
                  in vec3 pos,
                  in vec3 normal,
                  in int maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.9;
    const float specularStrength    = 0.4;
    const float shininess           = 256.0;

    vec3 lightDir   = normalize(lightPos - pos);
    vec3 viewDir    = normalize(camPos   - pos);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    // float shadow = ShadowRay(pos, lightPos, int(maxDistance * 0.5)) ? 0.05 : 1.0;
    float shadow = SoftShadowRay(pos, lightPos, normal, int(maxDistance));

    vec3 ambient    = ambientStrength * lightColor;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

// --------------------------------------------------------------------------------------------------------------------
vec3 Reflection(vec3 from,
                vec3 to,
                int maxSteps,
                uint bounces,
                vec3 baseColor,
                vec3 normal,
                float MaterialReflectPower)
{
    float localReflect = MaterialReflectPower;

    vec3 incident;
    vec3 dir;
    vec3 hit;
    uint index;
    float dummyDistance;
    vec3 normalRef;
    int hitType;

    vec3 reflectedColor = baseColor;
    vec4 hitBaseColor;
    const float roughness = 0.02;

    for (uint i = 0; i < bounces; ++i)
    {
        if (localReflect <= 0.0)
            break;

        dir = reflect(normalize(to - from), -normal);
        dir = mix(dir, RandomPointOnHemisphere(normal), roughness);

        if (!MarchTheRay(to + dir * EPSILON,
                        dir,
                        maxSteps,
                        hit,
                        index,
                        dummyDistance,
                        normalRef,
                        hitType)) 
        {
            reflectedColor = mix(reflectedColor, baseSkyColor.xyz, localReflect);
            break;
        }

        from    = to;
        to      = hit;
        normal  = normalRef;

        if (hitType == HIT_TYPE_VOXEL) {
            hitBaseColor = ExtractColorInt(CubeData[index].Color);
        }
        if (hitType == HIT_TYPE_OBJECT) {
            hitBaseColor = ExtractColorInt(VoxelData[index].Color);
        }
        
        reflectedColor = mix(reflectedColor, 
                             PhongShadows(CameraPos.xyz, hit, normal, int(maxSteps * 0.25)) * hitBaseColor.xyz,
                             localReflect);

        localReflect *= 0.23 * 2;
    }

    return reflectedColor;
}

// --------------------------------------------------------------------------------------------------------------------
void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov       = Fov * 0.5;
    float aspectRatio   = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale         = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 ro  = CameraPos.xyz;
    vec3 rd  = normalize(CameraLookDir.xyz +
                         uv.x * aspectRatio * scale * CameraRight.xyz +
                         uv.y * scale * CameraUp.xyz);

    vec4 finalColor = baseSkyColor;

    vec3 hitPos;
    uint index;
    float distance;
    vec3 normal;
    int hitType;

    if (MarchTheRay(ro, rd, maxSteps, hitPos, index, distance, normal, hitType)) 
    {
        if (hitType == HIT_TYPE_VOXEL) {
            finalColor = ExtractColorInt(VoxelData[index].Color);
        }
        if (hitType == HIT_TYPE_OBJECT) {
            finalColor = ExtractColorInt(CubeData[index].Color);
        }

        if (distance <= maxSteps) {
            vec3 shaded = PhongShadows(CameraPos.xyz, 
                                       hitPos,
                                       normal,
                                       int(length(hitPos - lightPos) * 1.5)) * finalColor.xyz;
            // finalColor = vec4(shaded, finalColor.w);

            finalColor = vec4(Reflection(ro, 
                                         hitPos, 
                                         maxSteps, 
                                         2, 
                                         shaded, 
                                         normal,
                                         0.25),
                              finalColor.w);
        }
    }

    if (distance > maxRenderDist)
        finalColor = mix(finalColor, 
                         baseSkyColor,
                         clamp(distance - maxRenderDist, 0.f, maxRenderDist * .5f) / (maxRenderDist * .5f));

    imageStore(outputImage, pixelCoord, finalColor);
}


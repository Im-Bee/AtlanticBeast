#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint type;
    uint color;
    uint padding;
    uint padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel voxelData[]; 
};

layout(push_constant, std430) uniform PushConstants 
{
    vec3    cameraPos;
    float   padding;
    ivec3   gridSize;
    uint    padding2;
    mat4    viewProjInverse;
};

vec3 computeNormal(ivec3 voxelCoord) {
    float dx = float(
        (voxelCoord.x + 1 < gridSize.x && voxelData[voxelCoord.x + 1 + voxelCoord.y * gridSize.x + voxelCoord.z * gridSize.x * gridSize.y].type == 1 ? 1 : 0) -
        (voxelCoord.x - 1 >= 0         && voxelData[voxelCoord.x - 1 + voxelCoord.y * gridSize.x + voxelCoord.z * gridSize.x * gridSize.y].type == 1 ? 1 : 0)
    );

    float dy = float(
        (voxelCoord.y + 1 < gridSize.y && voxelData[voxelCoord.x + (voxelCoord.y + 1) * gridSize.x + voxelCoord.z * gridSize.x * gridSize.y].type == 1 ? 1 : 0) -
        (voxelCoord.y - 1 >= 0         && voxelData[voxelCoord.x + (voxelCoord.y - 1) * gridSize.x + voxelCoord.z * gridSize.x * gridSize.y].type == 1 ? 1 : 0)
    );

    float dz = float(
        (voxelCoord.z + 1 < gridSize.z && voxelData[voxelCoord.x + voxelCoord.y * gridSize.x + (voxelCoord.z + 1) * gridSize.x * gridSize.y].type == 1 ? 1 : 0) -
        (voxelCoord.z - 1 >= 0         && voxelData[voxelCoord.x + voxelCoord.y * gridSize.x + (voxelCoord.z - 1) * gridSize.x * gridSize.y].type == 1 ? 1 : 0)
    );

    return -normalize(vec3(dx, dy, dz));
}


void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    vec3 internalCameraPos = vec3(20.0, 5.0, -55.0);
    vec3 internalUp = vec3(0.0, 1.0, 0.0);
    vec3 internalCameraLookDir = vec3(0.0, 0.0, 1.0);

    vec3 internalCameraRight = normalize(cross(internalUp, internalCameraLookDir));
    vec3 internalCameraUp = cross(internalCameraLookDir, internalCameraRight);

    float fov = radians(45.0);  // horizontal FOV
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(fov * 0.5);

    vec2 uv = ((vec2(pixelCoord) / vec2(imageSize(outputImage))));
    uv.x *= aspectRatio;

    vec3 rayDir = normalize(
        internalCameraLookDir +
        uv.x * scale * internalCameraRight +
        uv.y * scale * internalCameraUp
    );
     
    vec3 rayOrigin  = internalCameraPos;
    vec3 rayPos     = rayOrigin;

    const vec3 lightPos = vec3(10.0, 25.0, 10.0);
    const vec3 lightColor = vec3(1.0, 1.0, 1.0);
    const float ambientStrength = 0.1;
    const float diffuseStrength = 1.0;
    const float specularStrength = 0.5;
    const float shininess = 132.0;

    vec4 finalColor = vec4(0., 0., 0., 1.0);
    // for (int i = 0; i < 64 * 64 * 64; ++i) {
    //     Voxel voxel = voxelData[i];
    //     if (voxel.type == 1) {
    //         finalColor = vec4(1., 0., 1., 1.0);
    //         break;
    //     }
    // }
    // imageStore(outputImage, pixelCoord, finalColor);
    // return;

    int index = -1;
    for (int i = 0; 
         i < 4096; 
         ++i, rayPos += rayDir * 0.12) 
    {
        ivec3 voxelCoord = ivec3(floor(rayPos));
    
        
        index =     voxelCoord.x + 
                    (voxelCoord.y * gridSize.x) + 
                    (voxelCoord.z * gridSize.x * gridSize.y);

        if ((index < 0) || (index >= (gridSize.x * gridSize.y * gridSize.z))) {
            continue;
        }

        Voxel voxel = voxelData[index];
        if (voxel.type == 1) {
            float b = float((voxel.color << 16) >> 24) / 255.;
            float g = float((voxel.color << 8)  >> 24) / 255.;
            float r = float(voxel.color         >> 24) / 255.;
            float a = float(voxel.color) / 255.;
            vec3 baseColor = vec3(r, g, b);

            vec3 normal = computeNormal(voxelCoord);

            vec3 lightDir = normalize(lightPos - rayPos);
            vec3 viewDir = normalize(internalCameraPos - rayPos);
            vec3 reflectDir = reflect(-lightDir, normal);

            float diff = max(dot(normal, lightDir), 0.0);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);

            vec3 ambient = ambientStrength * lightColor;
            vec3 diffuse = diffuseStrength * diff * lightColor;
            vec3 specular = specularStrength * spec * lightColor;

            vec3 lighting = (ambient + diffuse + specular) * baseColor;

            finalColor = vec4(lighting, 1.0);
            break;
        }
    }

    // debugPrintfEXT("pixelCoord: %v2i uv: %v2f rayStart value: %v3f rayEnd value: %v3f rayDir: %v3f Index value: %d\n", pixelCoord.xy, uv, rayDir, rayDir, rayDir, index);
    imageStore(outputImage, pixelCoord, finalColor);
}


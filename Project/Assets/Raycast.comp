#version 450

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint Type;
    uint Color;
    uint Padding;
    uint Padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel VoxelData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    Padding1;
    uint    Padding2;
    uint    Padding3;
};

vec3 ComputeNormal(vec3 ro, vec3 hitCenter) 
{
    return normalize(ro - hitCenter);
}

bool MarchTheRay(vec3 ro, vec3 rd, out ivec3 hitCoords, out int hitIndex, out vec3 normal)
{
    vec3 pos = floor(ro);
    ivec3 voxel = ivec3(pos);

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;

    for (int i = 0; i < 3; ++i) {
        float offset = (rd[i] > 0.0) ? (1.0 - fract(ro[i])) : fract(ro[i]);
        tMax[i] = tDelta[i] * offset;
    }

    ivec3 step = ivec3(sign(rd));
    int lastStepAxis = -1;

    const int maxSteps = 256;
    normal = vec3(0.);

    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x < 0 || voxel.x >= GridSize.x ||
            voxel.y < 0 || voxel.y >= GridSize.y ||
            voxel.z < 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;

        if (VoxelData[index].Type == 1)
        {
            hitCoords = voxel;
            hitIndex = index;
            normal[lastStepAxis] = -float(step[lastStepAxis]);
            return true;
        }

        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                tMax.x  += tDelta.x;
                lastStepAxis = 0;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = 2;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                tMax.y  += tDelta.y;
                lastStepAxis = 1;
            } else {
                voxel.z += step.z;
                tMax.z  += tDelta.z;
                lastStepAxis = 2;
            }
        }
    }

    return false;
}

vec4 ExtractColorInt(uint packendColor)
{        
    float b = float((packendColor << 16) >> 24) / 255.;
    float g = float((packendColor << 8)  >> 24) / 255.;
    float r = float(packendColor         >> 24) / 255.;
    float a = float(packendColor & 0xFFu) / 255.;
    
    return vec4(r, g, b, a);
}

bool ShadowRay(vec3 from, vec3 to)
{
    vec3 dir = normalize(to - from);
    ivec3 dummyHit;
    int dummyIndex;
    vec3 dummyNormal;
    return MarchTheRay(from + dir * 2.2,
                       dir,
                       dummyHit,
                       dummyIndex,
                       dummyNormal);
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov = Fov * 0.5;
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 rayDir = normalize(CameraLookDir.xyz +
                            uv.x * aspectRatio * scale * CameraRight.xyz +
                            uv.y * scale * CameraUp.xyz);
     
    vec3 rayOrigin  = CameraPos.xyz;

    const vec4 baseSkyColor = vec4(.2, .3, .7, 1.0);

    const vec3 lightPos = vec3(20.0, 24.0, 10.0);
    const vec3 lightColor = vec3(1.0, 1.0, 1.0);
    const float ambientStrength = 0.04;
    const float diffuseStrength = 0.8;
    const float specularStrength = 1.0;
    const float shininess = 123.0;

    vec4 finalColor = baseSkyColor;

    ivec3 hitCoords;
    int index = 0;
    vec3 normal;
    if (MarchTheRay(rayOrigin, rayDir, hitCoords, index, normal)) 
    {
        Voxel voxel = VoxelData[index];

        vec4 baseColor = ExtractColorInt(voxel.Color);

        vec3 voxelCenter = vec3(hitCoords) + vec3(0.5);
                
        vec3 lightDir = normalize(lightPos - voxelCenter);
        vec3 viewDir = normalize(rayOrigin - voxelCenter);
        vec3 reflectDir = reflect(-lightDir, normal);

        float diff = max(dot(normal, lightDir), 0.0);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);

        vec3 ambient = ambientStrength * lightColor;
        vec3 diffuse = diffuseStrength * diff * lightColor;
        vec3 specular = specularStrength * spec * lightColor;

        float shadow = ShadowRay(voxelCenter, lightPos) ? 0.0 : 1.0;
        diffuse *= shadow;
        specular *= shadow;

        vec3 lighting = ambient + diffuse + specular;

        finalColor = vec4(lighting * baseColor.xyz, baseColor.w);
    }

    imageStore(outputImage, pixelCoord, finalColor);
}


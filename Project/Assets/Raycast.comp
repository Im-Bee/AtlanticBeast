#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint Type;
    uint Color;
    uint Padding;
    uint Padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel VoxelData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
};

vec3 computeNormal(ivec3 voxelCoord) {
    float dx = float(
        (voxelCoord.x + 1 < GridSize.x && VoxelData[voxelCoord.x + 1 + voxelCoord.y * GridSize.x + voxelCoord.z * GridSize.x * GridSize.y].Type == 1 ? 1 : 0) -
        (voxelCoord.x - 1 >= 0         && VoxelData[voxelCoord.x - 1 + voxelCoord.y * GridSize.x + voxelCoord.z * GridSize.x * GridSize.y].Type == 1 ? 1 : 0)
    );

    float dy = float(
        (voxelCoord.y + 1 < GridSize.y && VoxelData[voxelCoord.x + (voxelCoord.y + 1) * GridSize.x + voxelCoord.z * GridSize.x * GridSize.y].Type == 1 ? 1 : 0) -
        (voxelCoord.y - 1 >= 0         && VoxelData[voxelCoord.x + (voxelCoord.y - 1) * GridSize.x + voxelCoord.z * GridSize.x * GridSize.y].Type == 1 ? 1 : 0)
    );

    float dz = float(
        (voxelCoord.z + 1 < GridSize.z && VoxelData[voxelCoord.x + voxelCoord.y * GridSize.x + (voxelCoord.z + 1) * GridSize.x * GridSize.y].Type == 1 ? 1 : 0) -
        (voxelCoord.z - 1 >= 0         && VoxelData[voxelCoord.x + voxelCoord.y * GridSize.x + (voxelCoord.z - 1) * GridSize.x * GridSize.y].Type == 1 ? 1 : 0)
    );

    return -normalize(vec3(dx, dy, dz));
}


void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov = radians(45.0);
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 rayDir = normalize(CameraLookDir.xyz +
                            uv.x * aspectRatio * scale * CameraRight.xyz +
                            uv.y * scale * CameraUp.xyz);
     
    vec3 rayOrigin  = CameraPos.xyz;
    vec3 rayPos     = rayOrigin;

    const vec3 lightPos = vec3(10.0, 25.0, 10.0);
    const vec3 lightColor = vec3(1.0, 1.0, 1.0);
    const float ambientStrength = 0.15;
    const float diffuseStrength = 0.8;
    const float specularStrength = 1.8;
    const float shininess = 132.0;

    vec4 finalColor = vec4(.2, .3, .7, 1.0);

    int index = -1;
    for (int i = 0; 
         i < 1024; 
         ++i, rayPos += rayDir * 0.08) 
    {
        ivec3 voxelCoord = ivec3(floor(rayPos));
    
        if (voxelCoord.x < 0 || voxelCoord.x >= GridSize.x ||
            voxelCoord.y < 0 || voxelCoord.y >= GridSize.y ||
            voxelCoord.z < 0 || voxelCoord.z >= GridSize.z) {
            break;
        }
       
        index = voxelCoord.x + 
                (voxelCoord.y * GridSize.x) + 
                (voxelCoord.z * GridSize.x * GridSize.y);

        Voxel voxel = VoxelData[index];
        if (voxel.Type == 1) 
        {
            float b = float((voxel.Color << 16) >> 24) / 255.;
            float g = float((voxel.Color << 8)  >> 24) / 255.;
            float r = float(voxel.Color         >> 24) / 255.;
            float a = float(voxel.Color & 0xFFu) / 255.;
            vec3 baseColor = vec3(r, g, b);

            vec3 normal = computeNormal(voxelCoord);

            vec3 lightDir = normalize(lightPos - rayPos);
            vec3 viewDir = normalize(CameraPos.xyz - rayPos);
            vec3 reflectDir = reflect(-lightDir, normal);

            float diff = max(dot(normal, lightDir), 0.0);
            float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);

            vec3 ambient = ambientStrength * lightColor;
            vec3 diffuse = diffuseStrength * diff * lightColor;
            vec3 specular = specularStrength * spec * lightColor;

            vec3 lighting = (ambient + diffuse + specular) * baseColor;

            finalColor = vec4(lighting, 1.0);
            break;
        }
    }

    // debugPrintfEXT("pixelCoord: %v2i uv: %v2f rayStart value: %v3f rayEnd value: %v3f rayDir: %v3f Index value: %d\n", pixelCoord.xy, uv, rayDir, rayDir, rayDir, index);
    imageStore(outputImage, pixelCoord, finalColor);
}


#version 450

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint Type;
    uint Color;
    uint Padding;
    uint Padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel VoxelData[]; 
};

layout(push_constant) uniform PushConstants 
{
    vec4    CameraPos;
    ivec4   GridSize;
    vec4    CameraLookDir;
    vec4    CameraRight;
    vec4    CameraUp;
    float   Fov;
    uint    Padding1;
    uint    Padding2;
    uint    Padding3;
};

const vec4 baseSkyColor = vec4(.4078, .4725, 1., 1.);
const float maxRenderDist = 100.f;
float materialReflect = 0.43f;
const bool coloredBySky = false;

const vec3  lightPos    = vec3(20.0, 24.0, 10.0);
const vec3  lightColor  = vec3(1., 1., 1.);

bool MarchTheRay(vec3 ro, vec3 rd, int maxSteps, out ivec3 hitCoords, out int hitIndex, out float distance, out vec3 normal)
{
    vec3 pos = floor(ro);
    ivec3 voxel = ivec3(pos);

    vec3 invDir = 1.0 / rd;
    vec3 tDelta = abs(invDir);
    vec3 tMax;

    for (int i = 0; i < 3; ++i) {
        float offset = (rd[i] > 0.0) ? (1.0 - fract(ro[i])) : fract(ro[i]);
        tMax[i] = tDelta[i] * offset;
    }

    ivec3 step = ivec3(sign(rd));
    int lastStepAxis = -1;
    distance = 0.;

    normal = vec3(0.);

    for (int stepCount = 0; stepCount < maxSteps; ++stepCount)
    {
        if (voxel.x < 0 || voxel.x >= GridSize.x ||
            voxel.y < 0 || voxel.y >= GridSize.y ||
            voxel.z < 0 || voxel.z >= GridSize.z)
        {
            break;
        }

        int index = voxel.x + 
                    voxel.y * GridSize.x +
                    voxel.z * GridSize.x * GridSize.y;

        if (VoxelData[index].Type == 1)
        {
            hitCoords = voxel;
            hitIndex = index;
            normal[lastStepAxis] = -float(step[lastStepAxis]);
            return true;
        }

        if (tMax.x < tMax.y) 
        {
            if (tMax.x < tMax.z) {
                voxel.x += step.x;
                distance = tMax.x;
                tMax.x  += tDelta.x;
                lastStepAxis = 0;
            } else {
                voxel.z += step.z;
                distance = tMax.z;
                tMax.z  += tDelta.z;
                lastStepAxis = 2;
            }
        } 
        else 
        {
            if (tMax.y < tMax.z) {
                voxel.y += step.y;
                distance = tMax.y;
                tMax.y  += tDelta.y;
                lastStepAxis = 1;
            } else {
                voxel.z += step.z;
                distance = tMax.z;
                tMax.z  += tDelta.z;
                lastStepAxis = 2;
            }
        }
    }

    return false;
}

vec4 ExtractColorInt(uint packendColor)
{        
    float b = float((packendColor << 16) >> 24) / 255.;
    float g = float((packendColor << 8)  >> 24) / 255.;
    float r = float(packendColor         >> 24) / 255.;
    float a = float(packendColor & 0xFFu) / 255.;
    
    return vec4(r, g, b, a);
}

bool ShadowRay(vec3 from, vec3 to, int maxDistance)
{
    vec3    dir = normalize(to - from);
    ivec3   dummyHit;
    int     dummyIndex;
    float   dummyDistance;
    vec3    dummyNormal;

    return MarchTheRay(from + dir * 0.0001,
                       dir,
                       maxDistance,
                       dummyHit,
                       dummyIndex,
                       dummyDistance,
                       dummyNormal);
}

vec3 PhongShadows(in vec3 camPos, in vec3 pos, in vec3 coord, in vec3 normal, in int maxDistance)
{
    const float ambientStrength     = 0.1;
    const float diffuseStrength     = 0.8;
    const float specularStrength    = 0.7;
    const float shininess           = 64.0;

    vec3 lightDir   = normalize(lightPos - coord);
    vec3 viewDir    = normalize(camPos   - coord);
    vec3 reflectDir = normalize(lightDir + viewDir);

    float diff = max(dot(normal, lightDir), 0.0);
    float spec = pow(max(dot(normal, reflectDir), 0.0), shininess);
    float shadow = ShadowRay(pos, lightPos, int(maxDistance * 0.5)) ? 0.05 : 1.0;

    vec3 ambient    = ambientStrength * lightColor ;
    vec3 diffuse    = diffuseStrength * diff * lightColor * shadow;
    vec3 specular   = specularStrength * spec * lightColor * shadow;

    return ambient + diffuse + specular;
}

vec3 Reflection(vec3 from, vec3 to, int maxSteps, uint bounces, vec3 normal)
{
    vec3 incident;
    vec3 dir;
    ivec3 hit;
    int index;
    float distance;
    vec3 normalRef;

    vec3 reflectedColor = baseSkyColor.xyz;

    for (uint i = 0; i < bounces; ++i)
    {
        dir = reflect(normalize(to - from), normal);

        if (!MarchTheRay(to + dir * 0.001,
                        dir,
                        maxSteps,
                        hit,
                        index,
                        distance,
                        normalRef)) 
        {
            if (!coloredBySky)
                materialReflect = 0.1;

            break;
        }

        from = to;
        to = to + dir * distance;

        vec4 baseColor = ExtractColorInt(VoxelData[index].Color);
        
        if (i > 0 || coloredBySky) {
            reflectedColor = mix(reflectedColor, 
                                 PhongShadows(CameraPos.xyz, to, hit, normal, maxSteps) * baseColor.xyz,
                                 materialReflect);
        }
        else {
            reflectedColor = PhongShadows(CameraPos.xyz, to, hit, normal, maxSteps) * baseColor.xyz;
        }
    }

    return reflectedColor;
}

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    float halfFov = Fov * 0.5;
    float aspectRatio = float(imageSize(outputImage).x) / float(imageSize(outputImage).y);
    float scale = tan(halfFov);

    vec2 uv = ((vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(outputImage))) * 2. - 1.; 

    vec3 rayDir = normalize(CameraLookDir.xyz +
                            uv.x * aspectRatio * scale * CameraRight.xyz +
                            uv.y * scale * CameraUp.xyz);
     
    vec3 rayOrigin  = CameraPos.xyz;


    vec4 finalColor = baseSkyColor;

    ivec3   hitCoords;
    int     index = 0;
    vec3    normal;
    float   distance;

    if (MarchTheRay(rayOrigin, rayDir, 256, hitCoords, index, distance, normal)) 
    {
        vec3 hitPos = rayOrigin + rayDir * distance;
        vec4 baseColor = ExtractColorInt(VoxelData[index].Color);

        vec3 shading = PhongShadows(CameraPos.xyz, hitPos, hitCoords, normal, int(length(hitPos - lightPos) * 1.5));
        vec3 reflections = Reflection(rayOrigin, hitPos, 128, 4, normal);
        
        finalColor = vec4(mix(shading * baseColor.xyz, 
                              reflections, 
                              materialReflect), 
                          baseColor.w);
    }

    if (distance > maxRenderDist)
        finalColor = mix(finalColor, 
                         baseSkyColor,
                         clamp(distance - maxRenderDist, 0.f, maxRenderDist * .5f) / (maxRenderDist * .5f));

    vec2 d = abs(uv);

    bool isVertical   = d.x < (2. / imageSize(outputImage).x);
    bool isHorizontal = d.y < (2. / imageSize(outputImage).y);

    if (isVertical && isHorizontal) {
        finalColor = mix(finalColor, vec4(1., 1., 1., 1.), 0.32);
    }

    imageStore(outputImage, pixelCoord, finalColor);
}


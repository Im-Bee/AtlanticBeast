#version 450
#extension GL_EXT_debug_printf : enable

layout(local_size_x = 16, local_size_y = 16) in;

struct Voxel {
    uint type;
    uint color;
    uint padding;
    uint padding2;
};

layout(binding = 0, rgba8) uniform image2D outputImage;
layout(std430, binding = 1) readonly buffer Voxels {
    Voxel voxelData[]; 
};

layout(push_constant, std430) uniform PushConstants 
{
    vec3    cameraPos;
    float   padding;
    ivec3   gridSize;
    uint    padding2;
    mat4    viewProjInverse;
};

void main() 
{
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = ((vec2(pixelCoord) + 0.5) / vec2(imageSize(outputImage))) * 2.0 - 1.0;

    vec4 rayStart   = viewProjInverse * vec4(uv, 0.0, 1.0);
    vec4 rayEnd     = viewProjInverse * vec4(uv, 1.0, 1.0);
    vec3 rayDir     = normalize(rayEnd.xyz / rayEnd.w - rayStart.xyz / rayStart.w);
    rayDir.z *= -1.0;

     
    vec3 rayOrigin  = cameraPos;
    vec3 rayPos     = rayOrigin;

    vec4 finalColor = vec4(0., 0., 0., 1.0);
    // for (int i = 0; i < 64 * 64 * 64; ++i) {
    //     Voxel voxel = voxelData[i];
    //     if (voxel.type == 1) {
    //         finalColor = vec4(1., 0., 1., 1.0);
    //         break;
    //     }
    // }
    // imageStore(outputImage, pixelCoord, finalColor);
    // return;

    int index = -1;
    for (int i = 0; 
         i < 10240; 
         ++i, rayPos += rayDir * 0.01) 
    {
        ivec3 voxelCoord = ivec3(floor(rayPos));
    
        
        index = voxelCoord.x + 
                    (voxelCoord.y * gridSize.x) + 
                    (voxelCoord.z * gridSize.x * gridSize.y);
        if ((index < 0) || (index > (gridSize.x * gridSize.y * gridSize.z))) {
            continue;
        }

        Voxel voxel = voxelData[index];
        if (voxel.type == 1) {
            finalColor = vec4(1., 1., 0., 1.);
            break;
        }
    }

    debugPrintfEXT("ray value: %v3f\ndir value: %v3f\nIndex value: %d\n", rayPos, rayDir, index);
    imageStore(outputImage, pixelCoord, finalColor);
}

